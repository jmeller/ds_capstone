---
title: "Week 2: Milestone Report"
subtitle: "Data Science Capstone Project"
author: Jan
output: 
  html_notebook: 
    number_sections: yes
---
```{r load resources, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}
library(knitr)
library(kableExtra)
source('02_analysis.R')
```

# Executive summary

This report is part of the Coursera data science capstone project. Provided with a large corpus of text documents in the form of blog entries, tweets or news articles, the goal of this week's task is to perform first exploratory analyses and describe the further approach to build a next word prediction model. 

Given the considerable size of the whole corpus, I analyse a subsample that covers \approx 10\% of the total English texts. As expected, I find that the distribution of words in the data set is heavily skewed. However, since the goal of this project is a next word prediction model, I decided to preprocess the corpus without stopword removal. Moreover, I analysed the probability distribution of bigrams and trigrams within the corpus. Not surprisingly, since the bigram model results in higher probabilities than the trigram model, I am planning to use the former for the word prediction model.

# Exploratory data analysis

In my analysis, I focused on the English texts of the Swiftkey dataset which were provided as three single text documents containing lines of single contributions in the form of blog entries, news articles and tweets.
```{r echo=False, results='asis'}
kable(doc_overview, caption = "Overview on the data sources.", col.names = c('File name', 'No. of Documents'))
```

In total,there are ```r length(freq)``` words that occur in at least ```r (1-sparsity_threshold)*100```% of the documents. The following graph visualizes the number of occurences of terms that occur more than 15000 times in the corpus.
```{r plot_data, echo=FALSE}
plot_frequencies
```
In the following is a table of the 10 least frequently occurring terms in the corpus:

```{r, echo=FALSE, results='asis'}
kable(t(freq[tail(ord, n = 10)]))
```

In the following a word cloud of the most common words is displayed:
```{r echo=FALSE}
wordcloud(names(freq),freq,min.freq=2500,colors=brewer.pal(6,"Dark2"))
```


# Analysis of N-grams

For a first evaluation of n-grams, I used the #rstats-package ngram due to its good performance for large data sets. Not surprisingly, I find that the probabilities of an n-gram occuring are higher for the bigram as for the trigram. For this reason, I plan to use the bigram for my prediction algorithm.
```{r, echo = FALSE}
kable(head(bg_phrases, n=10), caption = "Bigrams", col.names = c('Bigram', 'Frequency', 'Probability')) %>% kable_styling(full_width = FALSE, position = "float_left")
kable(head(ng_phrases, n=10), caption = "Trigrams", col.names = c('Trigram', 'Frequency', 'Probability')) %>% kable_styling(full_width = FALSE, position = "left")
```

# Next steps

In the next week I will focus on the prediction model. In order to be able to train the model, first an evaluation routine has to be defined. 

In order to be able to measure the quality of my prediction model, I'm going to apply a train/test split. Hence, only the train subsample is going to be used to fit my actual prediction model to the data. Then, I measure the performance on the test set. In general, I assume that the higher the assigned probability to the **test** set is, the better my model performs. As a metric, I am going to use **perplexity** since minimizing perplexity is equivalent to maximizing probability.

Going forward, I plan to use a prediction model based on the ngrams that were generated by the data.